\chapter{Contraction Hierarchies}\label{chapter:ch}

\todo{Historie und Zitieren}

Die follgende Definition versucht unabhängig einer ERstellung zu argumentieren.

\begin{definition}[Level]
    Sei $G = V, E$ ein Graph.
    Sei $L \subseteq \mathbb{N}$ mit $\abs{L} = \abs{V}$.
    Dann wird eine bijketive Funktion ${vtl} \coloneq V \to L$ \emph{vertex-to-level} Funktion genannt.
    Ihre Umkehrfunktion ${ltv}$ wird \emph{level-to-vertex} Funktion genannt.
\end{definition}

\begin{definition}[Upward Graph]
    Sei $G = (V, E)$ und ${vtl}$ eine \emph{vertex-to-level} Funktion dazu. Dann ist $G_u = (V, E_u)$ ein \emph{upward Graph} zu $G$ wenn gilt:
    \begin{enumerate}
        \item\label{ch:definition:legal_edges}
        $E_u$ enthält nur Kanten $(t, h, w)$ mit $t, h \in V$ und $w \in \mathbb{N}$ für die ${vtl}(t) < {vtl}(h)$ und $w >= {spd}_{G}((t, h))$ gilt.

        \item\label{ch:definition:upward}
        $E_u$ enthält mindestens alle Kanten $(t, h, {spd}_{G}((t, h)))$ mit $t, h \in V$, für die gilt, dass $h$ das größte und $t$ das zweitgrößte Level auf allen kürzesten Wege auf $G$ von $t$ nach $h$ hat.
    \end{enumerate}
\end{definition}

Der Name des upward Graphen ergibt sich daher, dass die Suche in einem upward Graph auf das Level bezogen nur \emph{aufwärts} geht.

Betrachten wir das ganze an dem bereits definierten Beispielgraph.
Sei ${vtl}$ definiert durch die Abbildung
$\bigl(\begin{smallmatrix}
            a & b & c & d & e & f & g & h & i & j & k & \\
            4 & 3 & 7 & 2 & 6 & 1 & 5 & 0 & 8 & 10 & 9 &
        \end{smallmatrix}\bigr)$.

\begin{figure}
    \centering
    \begin{tikzpicture}
        % Nodes
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 0.0, 0.5* 8.5)  (a)    {a};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 2.1, 0.5* 2.1)  (b)    {b};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 10.0, 0.5* 1.2)  (c)    {c};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 16.6, 0.5* 0.5)  (d)    {d};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 22.0, 0.5* 2.2)  (e)    {e};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 19.7, 0.5* 8.0)  (f)    {f};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 13.5, 0.5* 10.7)  (g)    {g};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 6.5, 0.5* 11.0)  (h)    {h};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 4.0, 0.5* 6.0)  (i)    {i};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 9.0, 0.5* 5.7)  (j)    {j};
        \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 15.5, 0.5* 4.6)  (k)    {k};


        \draw[->]  (a) edge[bend left=15] node[circle, fill=white] {3} (j);

        \draw[->]  (b) edge node[circle, fill=white] {4} (a);
        \draw[->]  (b) edge node[circle, fill=white] {2} (j);

        \draw[->]  (c) edge node[circle, fill=white] {2} (j);
        \draw[->]  (c) edge node[circle, fill=white] {2} (k);

        \draw[->]  (d) edge node[circle, fill=white] {2} (k);

        \draw[->]  (e) edge node[circle, fill=white] {3} (d);
        \draw[->]  (e) edge node[circle, fill=white] {2} (k);

        \draw[->]  (f) edge node[circle, fill=white] {2} (k);

        \draw[->]  (g) edge node[circle, fill=white] {3} (f);
        \draw[->]  (g) edge node[circle, fill=white] {2} (j);
        \draw[->]  (g) edge node[circle, fill=white] {2} (k);

        \draw[->]  (h) edge node[circle, fill=white] {3} (a);
        \draw[->]  (h) edge node[circle, fill=white] {1} (j);

        \draw[->]  (i) edge node[circle, fill=white] {1} (a);
        \draw[->]  (i) edge node[circle, fill=white] {3} (b);
        \draw[->]  (i) edge node[circle, fill=white] {2} (j);


        \draw[->]  (k) edge node[circle, fill=white] {1} (j);
    \end{tikzpicture}
    \caption{Upward Graph des Beispielgraphs}
\end{figure}





Aus dieser Definition folgt, dass der kürzeste Pfad zwischen zwei Knoten in $G_u$ ist also mindestens genausolang ist wie in $G$.
% https://cstheory.stackexchange.com/questions/23767/why-is-label-pruning-possible-with-hub-labeling

\todo{Zeiche zwei Suchbäume, jeweils in G und Gu}

\begin{definition}[Downward Graph]
    Sei $G = (V, E)$ und ${vtl} \coloneq V \to \mathbb{N}$ eine \emph{vertex-to-level} Funktion. Dann ist ein upward Graph des Umkehrgraphens $G^T$ ein \emph{downward Graph} zu $G$.
\end{definition}

Ein \emph{Contracted Graph} ist die Datenstruktur, mit deren Hilfe schnell kürzeste Wege gefunden werden können.
Bevor im Folgenden verschiedene Arten beschrieben werden, wie, ein Contracted Graph erstellt werden kann, wird eine allgemeingültige Definition eingeführt.

\begin{algorithm}
    \caption{Construction Hierachies Query}
    \begin{algorithmic}[1]
        \Require Upward-Graph $G_u = (V, E_u)$, Downward-Graph $G_d = (V, E_d)$, Startknoten $s \in V$, Zielknoten $t \in V$
        \Ensure Treffknoten $m \in V \cup \{ {none} \}$, ${dist}_u$, ${pre}_u$, ${dist}_d$, ${pre}_d$
        \State ${dist}_u$, ${pre}_u$ $\leftarrow$ Dijkstra$(G_u, s)$
        \State ${dist}_d$, ${pre}_d$ $\leftarrow$ Dijkstra$(G_d, t)$

        \State
        \State $m \leftarrow {none}$
        \State $d \leftarrow \infty$
        \State

        \ForAll {$v \in V$}
        \If {${dist}_u(v) + {dist}_d(v) < d$}
        \State $m \leftarrow v$
        \State $d \leftarrow {dist}_u(v) + {dist}_d(v)$
        \EndIf
        \EndFor

        \State
        \State \Return $m$, ${dist}_u$, ${pre}_u$, ${dist}_d$, ${pre}_d$
    \end{algorithmic}
\end{algorithm}


Die Suche eines kürzesten Pfades von $u$ nach $v$ auf einem Contracted Graph gestaltet sich nun wie folgt:
Auf $G_u$ wird eine Breitensuche von $u$ und auf $G_d$ eine Breitensuche von $v$ durchgeführt.
\autoref{fig:ch:beispiel_suche} zeigt das auf- und absteigen der Level an einem Beispiel.

Gibt es einen Pfad von $u$ nach $v$, so werden beide Suchen den Knoten $t$ mit dem höchsten Level auf dem kürzesten Pfad finden.
Die kürzeste Pfad Distanz ist dann die Summe der Distanz der upward Suche ($u \to t$) und der downward Suche ($v \to t$).
Der kürzeste Pfad ist der setzt sich aus den beiden Pfaden der upward und downward Suche zusammen, wobei der in beiden Teilen vorkommenden Knoten $t$ in einem Teil entfernt und werden muss.
Da $G_d$ den Pfad von $v$ nach $t$ findet, muss dieser Teil des Pfades invertiert werden, bevor die Teilpfade konkatiniert werden.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}
        \node[circle, draw] at (0 * 1.5, -5 * 0.75)  (a)    {u};
        \node[circle, draw] at (1 * 1.5, -7 * 0.75)  (b)    {b};
        \node[circle, draw] at (2 * 1.5, -6 * 0.75)  (c)    {c};
        \node[circle, draw] at (3 * 1.5, -1 * 0.75)  (d)    {d};
        \node[circle, draw] at (4 * 1.5, -0 * 0.75)  (e)    {t};
        \node[circle, draw] at (5 * 1.5, -3 * 0.75)  (f)    {f};
        \node[circle, draw] at (6 * 1.5, -2 * 0.75)  (g)    {g};
        \node[circle, draw] at (7 * 1.5, -4 * 0.75)  (h)    {v};

        % draw axis
        \draw[->] (-1, -7 * 0.75) -- (-1, 0) node[above] {Level};

        \draw[->]  (a) -- (d);
        \draw[->]  (d) -- (e);
        \draw[->]  (h) -- (g);
        \draw[->]  (g) -- (e);

        \draw[->, dotted]  (a) -- (b);
        \draw[->, dotted]  (b) -- (c);
        \draw[->, dotted]  (c) -- (d);
        \draw[->, dotted]  (g) -- (f);
        \draw[->, dotted]  (f) -- (e);

    \end{tikzpicture}
    \caption{Beispiel einer Suche in einem Contrated Graph}
    \label{fig:ch:beispiel_suche}
\end{figure}

\begin{beweis}
    Der Beweis der Korrektheit folgt in zwei Schritte.

    \begin{enumerate}
        \item
              Es existiert ein kürzester Pfad von $u$ nach $v$ in $G$ $\Rightarrow$ Er wird in $C$ gefunden.

              Da ${vtl}$ injektiv ist, existiert genau ein Knoten $t$ mit dem höchstem Level. Zerscheide den Pfad $(u, \dotsc, v)$ in zwei Teile:  und $(u, \dotsc, t)$ und $(t, \dotsc, v)$. Die Tupel benachbarten Knoten in $(u, \dotsc, t)$ sind nach \autoref{ch:definition:downward} der Definition des upward Graph Kanten von $G_u$. Daher wird $t$ im upward Graph gefunden. Analog dazu wird $t$ in $G_d$ gefunden, die Tupel benachbarter Knoten im Pfad $(t, \dotsc, v)$ sind nach \autoref{ch:definition:upward} der Definition des downward Graphs Kanten von $G_d$.

              Da die Tupel Kanten der Graphen sind, findet eine Breitensuche sie.

        \item
              Es existiert kein kürzester Pfad von $u$ nach $v$ in $G$ $\Rightarrow$ Es wird in $C$ kein Pfad gefunden gefunden.

              Angenommen, es würde ein Pfad in C gefunden werden. Die Tupel benachbarter Knoten des Pfades müssten dann Kanten in C sein.
              Mindestens einer diese Kanten hätte dann ein Gewicht welches gegen \autoref{ch:definition:legal_edges} der Definition verstoßt.
    \end{enumerate}

    Daher gilt, die Suche der kürzesten Pfad Distanz in $C$ ist äquivalent zu der in $G$
\end{beweis}

\section{Erstellung}

Das Ziel der Contraction Hierarchies ist es aus dem Graph zwei Teilgraphe mit Abkürzungen (\emph{shortcuts}) zu erstellen.
Auf diesen Graphen kann mit einer Breitensuche effizient ein Knoten gefunden werden, der auf dem kürzesten Pfad zwischen zwei Knoten liegt.

\subsection{Contraction}

\begin{definition}[Vertex Contraction]
    Ein Knoten wird wie folgt konktraktiert.

    Für jeden Vorgänger und jeden Nachfolger:
    Wenn der Knoten auf dem einzigen kürzesten Pfad zwischen Vorgänger und Nachfolger liegt, füge einen Shortcut Vorgänger Nachfolger ein.
    Speichere ((Vorgänger, Nachgänger), Knoten) ab.

    Entferne jede Kante zu Vorgänger und Nachfolger.
\end{definition}

Für die verbleibenden Knoten bleibt der kürzeste Pfad erhalten.


\subsubsection{Top-Up}

Wenn $ltv$ gegeben ist, einfach alle Knoten von Level 0 aus startend kontraktieren.
Sammle alle Shortcuts.

Füge alle Shortcuts in den Graphen ein.
Erstelle upward Graph/dopward Graph aus Graph wobei upward  nur Level aufwärts.
downward Graph ist inverser Graph Level downwards.


\todo{überhaupt Möglich weil sum degree**2 zu hoch?}

Für die triangulierten Graphen ist es möglich den klassischen Contraction Hierarchie Algorithmus mit der Knoten-Differenz und Lazy-poping (\cite{geisberger2008contraction}) anzuwenden, wobei auch ein signifikanter Speedup erzielt werden kann. \todo{Tabelle Speedup}
Darauf aufbauend kann auch ein Hub Labeling erstellt werden, wodurch nochmals ein signifikanter Speedup erzielt werden kann.
Für die Sichtbarkeitsgraphen gilt dies jedoch nicht, auf den verwendeten Computern konnte für keinen von ihnen innerhalb von drei Tagen eine Erstellung abgeschlossen werden.
\todo{Wie weit sind sie gekommen? Was ist der größtmögliche Graph, für den dies möglich ist?}
Der Grund hierfür ist naheliegend: Der Algorithmus führt für jeden In-Nachbar eine one-to-many Suche zu allen Out-Nachbarn aus.
Die Durschnitliche Suchtiefe ist dabei sehr hoch, da Knoten des Sichtbarkeitsgraphen mit einer hohen Wahrscheinlichkeit eine Kanten mit großem Gewicht haben, die zum Beispiel über einen Ozean auf die am weitest entfernte Küste zeigt.
Das begrenzen der Suche auf wenige Hops ist dabei auch nicht hilfreich, da die Durschnitliche Hop-Länge von kürzesten Pfaden auf Sichtbarkeitsgraph gering ist eine so begrenzte Suche also viele kürzeste Pfade nicht finden würde.

Daher müssen für die Sichtbarkeitsgraphen andere Methoden gefunden werden.
Die naheliegendste Idee ist das direkte Berechnen der CH Edges und HL Labels.
Dies ist zwar sehr rechenintensiv, es muss für jeden Knoten eine one-to-many bzw. one-to-all Suche durchgeführt werden, dies ist jedoch schneller möglich, also für jeden in-Nachbar eine one-to-many Suche zu berechnen.


\subsubsection{Bottom-Up}

Erstelle $lvt$ Währen dem erstellen.

edge diff.

Greddy lazy poping vs neighbor update.

lazy poping für vis graphen nicht sinvoll?

Neighbor update für vis graphen nicht sinvoll?
Vielleicht nur updaten, nachdem n nachbarn contracted worden?

Vielleicht nur n mal insgesammt updaten? alle 10\% neu berechnen?



Heuristic egde difference (zufall)
Vis graphen haben sehr hohen degree (TODO Beweis).
Daher degree x degree viele checks, das gehtn schnell in die Millionen bis Milliarden.
Idee: betrachte nur ein Subset (tails, heads) und schaue ob und wie genau dieses die Edge difference aproximiert.

Das kann dann wieder für andere Methoden benutzt werden.

Plot hitting set vs bottom-up order


\subsubsection{Ideen}

Verwende eine Heuristik für Contractio


Wir betrachten Vertex v. tail -> v -> head.
Füge shortcut tail -> head ein, wenn tail -> v -> head der einzigste kürzste Weg ist.
Dafür eine one to many without v Vorwärtssuche.
shortcut wenn shortcut cost < dijkstra cost
without kann deutlich teuerer machen (TODO Beweis).

daher besser ohne without. Dann aber shortcut wenn cost <= dijkstra cost.
Die Ungleichung wird also abgeschwächt.
Zusätzlich kann man noch max\_hops anschauen, aber das ist für die Visibility Graphen nur bedingt sinvoll, da kürzste wege nur wenig hops. TODO Beweis

Heuristic.
Statt suche kann man auch heursitc benutzten.
shortcut distance < dijksta cost ==> shortcut distance <= upper bound
also shortcut distance <= upper bound => füge shortcut ein

Used heuristics:
TrivialeHeuristic (all in). Füge jeden shortcut ein.

Landmarks. Gut für größere Entfernungen.
Es reicht zu zeigen, dass shortcut distance > upperbound für ein Landmark ist. Dann bereits kein shortcut.
Viele Landmakrs, weniger shortcuts, mehr checks (vielleicht gibt es Break-Even point?). Wenige Landmarks, mehr shortcuts, weniger checks?
TODO Vielleicht noch check einbauen dass wenn shortcut distance == lower bound, dann shortcut zwingen notwendig ist.
TODO Wenn shortcut distance == lowerbound(head) - lowerbound(tail) dann checken ob tail auf landmark path (head). Oder ist das unnötig nach oben?

CH / HL als Heuristic.
Dann ist lowerbound == upperbound und damit wie dijkstra ohne without. Kann sich unter umständen lohnen.


\section{Hitting Set Berechnung}

\begin{algorithm}
    \caption{Greedy Hitting Set}
    \begin{algorithmic}[1]
        \Require Knotenmenge $V$, Pfade $P$ über $V$
        \Ensure Hitting-Set $H$ als geordnete Menge

        \State $H \gets \emptyset$

        \State

        \While{$P \neq \emptyset$}
        \State Wähle $v \in V$ mit $\abs{ \{ p \mid p \in P \colon v \in p \}}$ maximal.
        \State $H \gets \{v\} \cup H$
        \State $P \gets P \setminus \{p \in P \mid v \in p\}$
        \EndWhile

        \State

        \State \Return $H$
    \end{algorithmic}
\end{algorithm}

Vorraussetzung für das Bruteforcing ist eine Funktion $f \coloneq V \to \mathbb{N}$, welche den Knoten einem \emph{Level}

Level-to-vertex

TODO Edge difference factor
überlegung ist, nur wenige hops. Daher reicht es eigenbtlich direkte Nachbarn anschauen.

Hitting set
Berechne Hitting Set mit Dijkstra oder CH, HL aus vorheriger Runde.
TODO Qualität des Hitting Set durch aproximitation der HL Size.

Bottum up contraction auf graph, verwende dieses für Vis Graph.
TODO

Random


\section{Brute force}

Berechne die Kanten stupide nach Defintion. Hoffnung: Suche ist relativ lokal? TODO Beweis? Avg dijksta rang?

Das mit den Shortcuts ist dann nicht so einfach. TODO Bild

