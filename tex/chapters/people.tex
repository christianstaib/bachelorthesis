\chapter{PEOPLE: Predetermined Order, Prunded Label}\label{chapter:peopel}

Wie im \autoref{chapter:kontraktion} diskutiert wurde, ist Kontraktion von Graphen mit hohem durschnitlichen Knotengrad aufwendig.
Vielleicht ist die Kontraktion von ihnen sogar so aufwendig, dass sie sich nicht in sinvoller Zeit kontrahieren lassen
Trotzdem wäre es praktisch, wenn sich die Anfrage-Zeiten von Contraction Hierarchirs und Hierachical Hub Labeling auch auf sie übertragen ließen.
Hierfür charakterisieren wir den Contracted- und Hub-Graphen neu und stellen anschließend PEOPLE (\textbf{P}redetermined \textbf{O}rder, \textbf{P}runded \textbf{L}ab\textbf{e}l) vor, eine Methode wie Hub- und Contracted-Graphen mit einer vorgegeben vertex-to-level-Funktion ohne Knoten-Kontraktion erstellt werden können.

Um die Nachfolgende Definition vorzubereiten, betrachten wir ein Beispiel.
Sei $G = (V, E)$ mit $V \supset \{ u, v, w \}$ und $E = \{ (u, v, {spd}((u, v))), (v, w, {spd}((v, w))) \}$, ein Produkt einer Kontraktion, also zu Beginn mehr Kanten und nicht-isolierte Knoten entiehlt
Es soll nun $v$ kontraktiert werden.
Hierfür wir eine Kante $(u, w, {spd}((u, w)))$ eingefügt und die Kanten $(u, v), (v, w)$ entfernt.
Daraus können zwei Folgerungen gezogen werden:

\begin{enumerate}
  \item
    Es gibt einen kürzesten Pfad von $u$ nach $w$ in $G$ für den gilt, dass alle Knoten zwischen $u$ und $w$ bereits kontrahiert wurden.
    Diese haben daher auch ein niedrigeres Level als $u$ und $u$.

  \item
    $(u, w) \in E_u$ gilt genau dann, wenn $w$ das größte Level auf allen Pfaden von $u$ nach $w$.
    $(w, u) \in E_d$ gilt, wenn $u$ das größte Level hat.
\end{enumerate}

Basierend auf dieser Überlegung, definieren wir den Upward-Graph neu.

\begin{definition}[Upward-Graph]\label{people:def:upward_graph}
  Sei $G = (V, E)$ und ${vtl}$ eine vertex-to-level Funktion dazu.
  Dann ist $G_u = (V, E_u)$ ein \emph{Upward-Graph} zu $G$ wenn für jeden Knoten $t \in V$ gilt:

  \begin{itemize}
    \item
      $E_u$ enthält nur Kanten $(t, h, d)$ mit $h \in V$ und $d \in \mathbb{R}^+$, für die es einen $t$-$h$ Pfad der Länge $d \geq {spd}_G (t, g)$ gibt, so dass auf ihm $h$ das größte und $t$ das zweitgrößte Level hat.

    \item
      $E_u$ enthält alle Kante $(t, h, {spd}_G (t, h))$ mit $h \in V$, für die gilt, dass auf \emph{allen} $t$-$h$ Pfaden $h$ das größte und $t$ zweitgröste Level hat.
  \end{itemize}
\end{definition}

Betrachten wir dies wieder am Beispielgraph.
Sei ${vtl}$ definiert durch die Abbildung in \autoref{ch::fig::vtl_abbildung} definiert.
Durch Anwendung der neuen Definition des Upward-Graph ergibt sich der in \autoref{ch::fig::upward_graph} gezeigte Graph.

\begin{table}[ht]
  \centering
  \begin{tabular}{lllllllllllll}
    Vertex & a & b & c & d & e & f & g & h & i & j  & k & \\
    Level  & 8 & 7 & 3 & 6 & 2 & 5 & 1 & 4 & 0 & 10 & 9 &
  \end{tabular}
  \caption{${vtl}$ Beispielfunktion}
  \label{ch::fig::vtl_abbildung}
\end{table}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    % Nodes
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 0.0, 0.5* 8.5)  (a)    {a};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 2.1, 0.5* 2.1)  (b)    {b};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 10.0, 0.5* 1.2)  (c)    {c};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 16.6, 0.5* 0.5)  (d)    {d};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 22.0, 0.5* 2.2)  (e)    {e};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 19.7, 0.5* 8.0)  (f)    {f};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 13.5, 0.5* 10.7)  (g)    {g};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 6.5, 0.5* 11.0)  (h)    {h};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 4.0, 0.5* 6.0)  (i)    {i};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 9.0, 0.5* 5.7)  (j)    {j};
    \node[circle, draw, minimum size=0.6cm, inner sep=0pt] at (0.5* 15.5, 0.5* 4.6)  (k)    {k};

    \draw[->]  (a) edge[bend left=15] node[circle, fill=white] {3} (j);

    \draw[->]  (b) edge node[circle, fill=white] {4} (a);
    \draw[->]  (b) edge node[circle, fill=white] {2} (j);

    \draw[->]  (c) edge node[circle, fill=white] {2} (j);
    \draw[->]  (c) edge node[circle, fill=white] {2} (k);

    \draw[->]  (d) edge node[circle, fill=white] {2} (k);

    \draw[->]  (e) edge node[circle, fill=white] {3} (d);
    \draw[->]  (e) edge node[circle, fill=white] {2} (k);

    \draw[->]  (f) edge node[circle, fill=white] {2} (k);

    \draw[->]  (g) edge node[circle, fill=white] {3} (f);
    \draw[->]  (g) edge node[circle, fill=white] {2} (j);
    \draw[->]  (g) edge node[circle, fill=white] {2} (k);

    \draw[->]  (h) edge node[circle, fill=white] {3} (a);
    \draw[->]  (h) edge node[circle, fill=white] {1} (j);

    \draw[->]  (i) edge node[circle, fill=white] {1} (a);
    \draw[->]  (i) edge node[circle, fill=white] {3} (b);
    \draw[->]  (i) edge node[circle, fill=white] {2} (j);

    \draw[->]  (k) edge node[circle, fill=white] {1} (j);
  \end{tikzpicture}
  \caption{Upward-Graph des Beispielgraphs}
  \label{ch::fig::upward_graph}
\end{figure}

Die Definition des Downward-Graphens erfolgt nun analog zu der des Upward-Graphens:

\begin{definition}[Downward-Graph]
  Sei $G = (V, E)$ und ${vtl}$ eine \emph{vertex-to-level} Funktion dazu. Dann ist ein Upward-Graph des Umkehrgraphens $G^T$ ein \emph{Downward-Graph} zu $G$.
\end{definition}

Wenn ein Graph ungerichtet ist, dann ist er äuivalent zu seinem Umkehrgraphen und dann ist auch der Upward und Downward Graph äuivalent.
Daher entspricht \autoref{ch::fig::upward_graph} gleichzeitig auch dem Downward Graph des Beispielgraphens.
Es ist zu zeigen, dass Anfragen auf einem auf diese Art definiertem Contracted-Graph $C = (G_u, G_d)$ ebenfalls Korrekt sind.

\begin{beweis}[Korrektheit Contracted-Graph Anfrage]
  Da im Upward- und Downard-Graphen nur Kanten existieren, deren Gewicht mindestens der kürzesten Pfad Abstand der verbundenen Knoten enspricht, kann in $C$ kein Pfad gefunden werden, der nicht auch in $G$ exisitert.

  Sei ${sp}_G(s, t)$ der kürzeste Pfad auf $G$ der unter allen kürzesten Pfaden den Knoten $m$ mit dem höchsten Level enthält.
  Erstelle aus diesem Pfad $(s, \dotsc, t)$ zwei Pfade: $(s, \dotsc, m)$ und $(t, \dotsc, m)$.
  Betrachte den Teilpfad $(s, \dotsc, m)$ der Hop-Länge $n_s$.
  Ist $n_s = 1$, so ist nichts weiter zu zeigen.

  Finde nun den ersten Knoten $s'$ nach $s$, für den gilt, dass sein Level größer als das von $s$ ist und zwischen denen auf allen Pfaden nur Knoten kleiner Level liegen.
  Für diesen gibt es nach der Definiton des Upward-Graphen eine Kante mit optimalem Gewicht in ihm.
  Widerhole dies für denn Teilpfad $(s', \dotsc, m)$, bis $s' = m$.
  Durch diese Kanten lässt sich $m$ von $s$ aus in $C$ mit optimaler Distanz finden.

  Analog wird für den Teilpfad $(t, \dotsc, m)$ im Downward-Graphen argumentiert.
  \qed
\end{beweis}

Dass nur Kanten $(t, h)$ erstellt werden müssen, wenn $h$ das größte und $t$ das zweitgrößte Level auf allen $t$-$h$-Pfaden hat, ist in \autoref{fig:people:notwendige_kanten} veranschaulicht.
Es muss keine $(u, w)$ Kante erstellt werden, da $w$ über $v$ erreicht werden kann.

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[scale=1.75]
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (0*1.25, 0)  (u)    {u\\0};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (1*1.25, 0)  (v)    {v\\1};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2*1.25, 0)  (w)    {w\\2};

    \draw[->]  (u) edge[bend left=45] node[circle, fill=white] {2} (w);
    \draw[->]  (u) edge node[circle, fill=white] {1} (v);
    \draw[->]  (v) edge node[circle, fill=white] {1} (w);
  \end{tikzpicture}
  \caption{Beispiel notwendiger Kanten im Upward-Graph}
  \label{fig:people:notwendige_kanten}
\end{figure}

\subsection{Kontraktion erfüllt diese Definition}

Bei der Knoten-Kontraktion des Knoten $v$ wird für den Pfad $(u, v, w)$ eine Abkürzung eingefügt, wenn dies der einzige kürzeste $u$-$w$-Pfad ist.
Ist dies der Fall, dann wurden die Knoten aller andern kürzesten Pfade zuvor bereits kontrahiert und haben daher ein niedrigeres Level.
Daher bilden diese Abkürzungen mitsamt den Kanten des ursprünglichen Graphen die Kantenmenge des Upward- und Downward-Graphen.
Wird die Kontraktionsbedingung abgeschwächt, so werden nicht notwendige, nicht optimale $(v, w)$ Kanten eingefügt, die dann einem nicht optimalen Pfad enstprechen auf dem $v$ und $w$ die beiden höchsten Level haben.
Daher entspricht ein durch Graphen-Kontraktion erzeugter Graph der neuen Definition.

\section{Contracted Graph Algorithmus}

Das Berechnen aller kürzesten Pfade zwischen zwei Knoten ist aufwändig, daher wird zum Berechnen eines so defineirten Contracted Graphens ein ähnlichen Trick angewendet, wie er bei der Knoten Kontraktion angewandt wird:
Wir fügen Kanten ein, sobald wir \emph{einen} optimalten $t$-$h$-Pfad gefunden haben, auf dem $h$ das größte und $t$ das zweitgrößte Level hat.
Dies ist hinreichend um die Bedingung zu erfüllen, fügt im Zweifel jedoch mehr Kanten als notwendig ein.

Um einen Upward Graphen zu berechnen, wird für jeden Knoten $t \in V$ eine angepasste Dijkstra Suche ausgeführt, bei der für jeden Knoten jeweils notiert wird, was größte Level auf dem Pfad zur Wurzel ist.
Dies Information kann mit der \emph{max-on-path} Funktion ${mop}$ abegrufen werden.
Ein Knoten $h \in V$, $h \neq t$ ist der Kopf eine Upward Graph Kante, für die gilt, dass ${mop}(h) = {vtl}(h)$ und ${mop}({pre}(h)) = {vtl}(t)$.
Das Gewicht der Kante kann der Dijkstra Suche entommen werden.
Die Suche kann abgebrochen werden, wenn nur noch Knoten für alle nicht-expandierten Knoten $h$ gilt dass ${mop}({pre}(h)) > {vtl}(h)$ ist.
\autoref{ch:fig:brute_force_suchbaum} zeigt dies für den Knoten $a$ im Beispielgraphen.
Die linke Zahl steht dabei für das Level des jeweiligen Knoten, die rechte Zahl für das größte Level auf dem Pfad zur Wurzel.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[scale=0.8]
    % Nodes
    % a & b & c & d & e & f & g & h & i & j & k &
    % 8 & 7 & 3 & 6 & 2 & 5 & 1 & 4 & 0 & 10 & 9 &

    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 1, 0)  (a)    {a\\8 8};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 0, 4)  (b)    {b\\7 8};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 1, 6)  (c)    {c\\3 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 1, 8)  (d)    {d\\6 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 2, 9)  (e)    {e\\2 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 3, 10)  (f)    {f\\5 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 3, 7)  (g)    {g\\1 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 1, 2)  (h)    {h\\4 8};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 2, 1)  (i)    {i\\0 8};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 2, 3)  (j)    {j\\10 10};
    \node[circle, draw, minimum size=1.2cm, inner sep=0pt , align=center] at (2* 2, 5)  (k)    {k\\9 10};

    \draw[->]  (a) edge (b);
    \draw[->]  (a) edge (h);
    \draw[->]  (a) edge (i);
    \draw[->]  (j) edge (c);
    \draw[->]  (i) edge (j);
    \draw[->]  (k) edge (d);
    \draw[->]  (j) edge (k);
    \draw[->]  (k) edge (e);
    \draw[->]  (k) edge (f);
    \draw[->]  (j) edge (g);

    \draw[->] (-2, 0) -- (-2, 10) node[above] {Zeitpunkt der Expansion};

    \draw (-2.5, 4.5) -- (-1.5, 4.5) node[left=1cm] {Abbruch Möglich};

  \end{tikzpicture}
  \caption{Brute-Force Suche}
  \label{ch:fig:brute_force_suchbaum}
\end{figure}

Die Informtion des größten Levels auf dem Pfad zur Wurzel kann dabei beim Update eines Kontens übertragen werden, indem das Maximum des bisherigen größten Levels und das Level des upgedateten Knoten gebildet wird.
Die Abbruchbedingung kann durch die Verfolgung einer Menge an \emph{lebendigen Knoten} erzielt werden, sobald diese keine Knoten mehr entählt, kann die Suche abgebrochen werden.
Zu beginn ist nur der Startknoten lebendig, die Lebendigkeit wird jeweils an die Kinder vererbt.
Ein Knoten stirbt, nachdem er expandiert wurde oder wenn er den Kopf einer Kante bildet.
Gibt es keine lebendigen Knoten mehr, so kann die Suche abgebrochen werden.
In dem verwendeten Beispiel wäre dies etwa nach der Expansion von $b$ der Fall.
Die Berechung ist \emph{embarrassingly parallel}, da jeder Knoten für sich selbst Berechnet werden kann.
Der textuell beschriebene Algorithmus wird dann wie folgt formal definiert:

\begin{algorithm}[ht]
  \caption{Contracted Graph Brute Force Suchalgorithmus}
  \begin{algorithmic}[1]
    \Require Graph $G = (V, E)$, vertex-to-level Funktion ${vtl}$, Startknoten $s \in V$, Zielknoten $t \in V$
    \Ensure $E_s$
    \State // Initialisiere Distanz- und Vorgänger-Funktion
    \ForAll{$v \in V$}
    \State ${dist}(v) \leftarrow \infty$
    \State ${pre}(v) \leftarrow {none}$
    \EndFor

    \State
    \State // Initialisiere Suche
    \State ${dist}(s) \leftarrow 0$
    \State $Q\leftarrow \{ s \}$
    \State ${pre}(s) \leftarrow s$

    \State
    \State // Initialisiere max-on-path
    \State ${mop}(s) \leftarrow {vtl}(s)$
    \State $E_s \leftarrow \{ \}$
    \State ${alive} \leftarrow \{ s \}$

    \State
    \While{$Q \neq \emptyset \land {alive} \neq \emptyset$}
    \State $u \leftarrow{extract\_min}(Q)$\label{graphs:dijkstra:pop}

    \State
    \State // Beende frühzeitig wenn Zielknoten gefunden wurde
    \If {$u \neq s \land {mop}(u) = {vtl}(u)$}
    \State $E_s \leftarrow E_s \cup \{ (s, u, {dist}(u)) \}$
    \State ${alive} \leftarrow {alive} \setminus \{ s \}$
    \EndIf

    \State
    \State // Aktualisiere Nachbarn
    \ForAll{$(u, v, w) \in E$}
    \If {${dist}(u) + w < {dist}(v)$}
    \State ${dist}(v) \leftarrow {dist}(u) + w$
    \State ${pre}(u) \leftarrow v$
    \State $Q = Q \cup \{ v \}$
    \State
    \State // setze max\_level\_path
    \State ${mop}(v) \leftarrow \max({mop}(v), {vtl}(v))$
    \If {$u \in {alive}$}
    \State ${alive} \leftarrow {alive} \cup \{ s \}$
    \EndIf
    \EndIf
    \EndFor

    \State ${alive} \leftarrow {alive} \setminus \{ s \}$

    \EndWhile

    \State
    \State \Return $E_s$
  \end{algorithmic}
\end{algorithm}

\subsection{Abkürzung Problem}

Es liegt nahe als abgekürzten Knoten den Knoten mit dem dritthöchsten Level auszuwählen und sich darauf zu verlassen, dass die Suche von diesem Knoten aus die nächsen Abkürzung findet, da dies der Knoten-Kontraktion enstpricht.
Dies ist praktisch, da dann jeder Shortcut nur einmal erstellt werden muss, dafür muss jedoch gelten, dass die Vorwärtssuche für $s$-$t$ den gleichen Pfad findet wie die Rückwärtssuche (die Suche auf dem Transponierten Graphen) für $t$-$s$.
Wird als Graph eine Datenstruktur verwendet, welche die Nachbarn nicht in einer definierten Ordnung ausgibt (etwa ein Hashset), oder eine nicht stabile Prioritätswarteschlange verwendet, ist dies nicht garantiert.

\autoref{ch:fig:problem_shortcut} zeigt eine Situation, in der dies auftreten kann.
In $C$ wurde der Pfad $(a, e)$ gefunden, dess Abkürzungen jetzt ersetzt werden sollen.
Hierfür wird im ersten Schritt die für die Abkürzung $(a, e)$ der abgekürzte Knoten $d$ gefunden, dadurch ist der Pfad $(a, d, e)$.
Für den Knoten $a$ wird die Kante $(a, e)$ mit dem abgekürzten Knoten $d$ gefunden.
Wir verlassen uns darauf, dass die Suche von $d$ aus die Abkürzung $(d, a)$ mit dem Knoten $b$ findet, dies geschieht jedoch nicht, wenn von $d$ aus $a$ über $c$ erreicht wird.

\begin{figure}[h!]
  \centering

  \begin{tikzpicture}
    % Nodes
    \node[circle, draw, minimum size=1cm, inner sep=0pt, align=left] at (2*0, 2*0)  (a)    {a\\3};
    \node[circle, draw, minimum size=1cm, inner sep=0pt, align=left] at (2*1, 2*0)  (b)    {b\\0};
    \node[circle, draw, minimum size=1cm, inner sep=0pt, align=left] at (2*1, 2*-1)  (c)    {c\\2};
    \node[circle, draw, minimum size=1cm, inner sep=0pt, align=left] at (2*2, 2*0)  (d)    {d\\1};
    \node[circle, draw, minimum size=1cm, inner sep=0pt, align=left] at (2*3, 2*0)  (e)    {e\\4};

    \draw[<->]  (a) edge node[circle, fill=white] {1} (b);
    \draw[<->]  (b) edge node[circle, fill=white] {1} (d);
    \draw[<->]  (d) edge node[circle, fill=white] {1} (e);

    \draw[<->]  (a) edge node[circle, fill=white] {1} (c);
    \draw[<->]  (c) edge node[circle, fill=white] {1} (d);
  \end{tikzpicture}
  \caption{Problem beim Shortcut erstellen}
  \label{ch:fig:problem_shortcut}
\end{figure}

Für dieses Problem gibt es zwei Lösungen:
Die Nachfolgenden Abkürzungen, welche benötigt werden, um eine Abkürzung vollständig zu entpacken werden für jede Abkürzung ebenfalls erstellt, dadurch werden viele Abkürzungen mehrfach erstellt, dies muss daher synchronisiert werden.
Alternativ kann die Prioritätswarteschlange modifiziert werden, indem es eine Totalordnung der Knoten gibt und diese bestimmt, in welcher Reihenfolge Knoten gleicher Distanz expandiert werden.

\section{Hub Labels Algorithmus}

Analog zur neuen Definition des Contracted-Graph lässt sich auch der Hub-Graph neu Definieren.
Die dafür verwendete Defintion der Forward-Label weicht nur leicht von der des Upward-Graphen ab.

\begin{definition}[Forward-Label]
  Sei $G = (V, E)$ und ${vtl}$ eine vertex-to-level Funktion dazu.
  Dann ist $L_f (t) \subset V \times \mathbb{R}$ ein Forward-Label für einen Knoten $t$ in $G$ wenn gilt:

  \begin{itemize}
    \item
      $L_f (t)$ enthält nur Einträge $(h, d)$ mit $h \in V$ und $d \in \mathbb{R}$, für die es einen $t$-$h$ Pfad der Länge $d \geq {spd}_G (t, g)$ gibt, so dass auf ihm $h$ das größte und $t$ das zweitgrößte Level hat.

    \item
      $L_f (t)$ enthält alle Einträge $(h, {spd}_G (t, h))$ mit $h \in V$, für die gilt, dass auf \emph{allen} $t$-$h$ Pfaden $h$ das größte und $t$ zweitgröste Level hat.
  \end{itemize}
\end{definition}

Hierbei ist ein Backward-Label ein Forward-Label das Transponierten Graphen $G^T$ .
Solche Label können wieder durch Merging aus einem Contracted-Graph erstellt worden durch eine Suche pro Knoten.
\todo{Algorithmus}
Die Suche pro Knoten erstellt dabei geprunte Label und kann kann auch dafür benutzt werden, die Qualität (durschnitliche Label Size) einer vertex-to-level Funktion anzugeben, ohne den kompletten Hub Graphen zu berechnen.
Hierfür würd für $n$ Knoten das Label berechnet und die größte des Labels angegeben.
Da sich dies leicht parallelisiern läst, könnte in einem zukünftigen Schritt durch Opmierungsalgorithmen die Label Size verkleinert werden.
