\chapter{Hub Labels}\label{chapter:hl}

Die CH Query erstellt ohne Stopbedingung jeweils den vollen Suchbaum für den Start und Zielknoten und sucht danach den Knoten mit geringester Summe der Distanzen in beiden Bäumen.
Die Idee des Hub Label ist es, diese Suche für jeden Knoten zu speichern.
Daher repräsentiert ein Label ein Graph.
Jeder Vertex hat demensprechend ein forward und backward label.
Das einzige schwierige ist es dann noch, die beiden Bäume effizient zu vergleichen.
Dafür einfach die Label nach Vertices sortieren.


\begin{definition}[Hub Label]
    Sei $G = (V, E)$ ein Graph.

    Ein \emph{Label Eintrag} ist ein Tupel $(h, d)$ mit $h \in V$, $d \in \mathbb{R}^+V$.

    Ein \emph{Hub Label} ist ein $n$-Tupel über Hub Einträge, wobei die Tuple nach dem ersten Eintrag sortiert sind.
\end{definition}

\todo{Wie hängen kleinstes und optimales hitting set zusammen?}



\begin{algorithm}
    \caption{Hub Label Query}
    \begin{algorithmic}[1]
        \Require Forward Labels $F$, Reverse Labels $R$, Startknoten $s \in V$, Zielknoten $t \in V$
        \Ensure Treffknoten $m \in V \cup \{ {none} \}$, ${dist}_u$
        \State $f \leftarrow F[s]$
        \State $r \leftarrow F[t]$

        \State
        \State $m, d \leftarrow {minimal\_overlapp}((f, r))$

        \State
        \State \Return $m$, $d$
    \end{algorithmic}
\end{algorithm}

\begin{table}[]
    \centering
    \begin{tabular}{@{}llllll@{}}
        \toprule
        Index           &  & 0 & 1 & 2 & 2 \\ \midrule
        Vertex          &  &   &   &   &   \\
        Distanz         &  &   &   &   &   \\
        Vorgänger Index &  &   &   &   &   \\ \bottomrule
    \end{tabular}
\end{table}

Die HL Query ist es dann den overlapp zweier Labels zu finden.
Damit das leicht möglich ist, werden die Einträge (Vertex, Distanz, Vorgänger Index) im Label nach Vertex sortiert gespeichert.
Die Abfrage ist dann ein merge sort likes vergleichen beider Label. Ein Weg existiert, wenn es ein Vertex gibt, welches in beiden Labeln vorhanden ist.
der kürzste pfad ist dementsprechend dann der Vertex mit geringster forward = backward distanz.
Der Vorgänger ist jeweils nicht der Vertex im Label der unter Vorgänger Index zu finden ist. Der Vertex, dem das Label label gehört hat keinen Vorgänger.

Shortcut replacement analog zu CH.

\section{Erstellung}

\subsection{Merging}
Gibt es bereits eine CH, dann kann diese leicht in eine HL umgewandelt werden.
Für jeden Vertex wird ein Label erstellt, dass den Vertex enthält.
Vom Vertex mit dem höchstem Level zum niedrigsten Level werden die Labels der Nachbarn gemerged, wobei für duplikate unter den Vertices die niedrigste Distanz gewähl wird.

Da CH Suchbaum nicht optimal ist, ist das Label viel größer, als es sein müsste. Daher sollte das Label noch geprunt werden.
Beim Pruning werden die Vertices aus dem Label entfernt, die keine optimale Distanz haben.
Da ein Label nur Vertices mit mindestem dem gleichem Level wie sich selbst enhält sind die für diese Vertices die Label bereits erstellt.
Diese können zum prunnen verwendet werden.
Das nennt man Boostraping.

\subsection{Brute force}
Dijksta Suche.
max level path ist eine HashMap die den bisher größten Level auf dem Pfad zur Wurzel beschreibt.
Ein Label enthält genau die Knoten für die gilt level(vertesx) == max level path.

Shortcut wieder schwierig.
