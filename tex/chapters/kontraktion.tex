\chapter{Kontraktion in Sichtbarkeitsgraphen}\label{chapter:kontraktion}

Die zuvor beschriebene Kontraktion von Knoten und Graphen ist bei Graphen mit hohen Knotengraden, wie zum Beispiel Sichtbarkeitsgraphen, deutlich rechenintensiver als bei Graphen mit geringeren Knotengraden, wie etwa Straßengraphen.
Für die Knoten-Kontraktion muss für jeden Vorgängerknoten eine Dijkstra-Suche durchgeführt werden, und für jedes Paar aus Vorgänger und Nachfolger ist zu prüfen, ob eine Abkürzung eingefügt werden muss.
Ein hoher Knotengrad bedeutet somit viele Dijkstra-Suchen und zahlreiche Vergleiche, ob eine Abkürzung notwendig ist.

Bei der Bottom-Up-Kontraktion wird die Kontraktion potenziell mehrfach simuliert, bevor sie wirklich ausgeführt wird.
Bei Lazy-Popping werden die Knoten oft nicht kontraktiert, sondern mit aktualisiertem Heuristik-Wert in die Warteschlange zurückgeschoben.
Beim Neighbor-Update sind jeweils sehr viele Nachbarn zu aktualisieren.
Auch das Einfügen und Löschen von Kanten stellt hierbei einen nicht zu vernachlässigenden Zeitfaktor dar.

Um Graphen mit hohen Knotengraden effizient zu kontrahieren, ist es entscheidend, die Kontraktion einzelner Knoten zu beschleunigen und eine effizient sowie effizient erstellbare Reihenfolge der Kontraktionen zu finden.
Auch die zur Repräsentation von Graphen verwendeten Datenstrukturen sollten betrachtet werden, damit das Finden von Nachbarn sowie das Einfügen und Löschen von Kanten effizient und parallel möglich ist.

\section{Kontraktion mit oberer Schranke}
Anstelle einer potenziell rechenintensiven Dijkstra-Suche pro Vorgänger kann eine Heuristik pro Paar aus Vorgänger und Nachfolger eine obere Schranke für den Abstand geben.
Eine Kante als Abkürzung wird dann eingefügt, wenn ihre Länge kleiner oder gleich der berechneten oberen Schranke für den Abstand ist.
Damit dies für die Kontraktion eines einzelnen Knotens effizienter ist, muss die Ermittlung der Heuristik für alle Paare eines bestimmten Vorgängers und aller Nachfolger schneller sein als die Dijkstra-Suche.
Damit die Kontraktion des gesamten Graphen effizient bleibt, müssen die Folgekosten unnötiger Kanten geringer sein als der Zeitgewinn durch den Einsatz der Heuristik.
Im Folgenden werden verschiedene Heuristiken diskutiert.

\subsection{Triviale Heuristik}
Die \emph{Triviale Heuristik} setzt die obere Schranke für jedes Knotenpaar auf $\infty$.
Dies bedeutet, dass für jedes Paar aus Vorgänger und Nachfolger, unabhängig von der tatsächlichen Distanz, eine Kante als Abkürzung eingefügt wird.
Unter der Annahme, dass in Graphen mit sehr hohem Knotengrad fast alle Nachbarn bereits mit einer Kante verbunden sind, könnte der Anteil der unnötig eingefügten Abkürzungen im Vergleich zu den notwendigen vernachlässigbar sein.

\subsection{Vereinfacher Graph}
Sei $G = (V, E)$ der zu kontrahierende Graph.
Lässt sich zu $G$ effizient ein vereinfachter Graph $G' = (V, E')$ mit $\forall s, t \in V \colon {spd}_{G'} ((s, t)) \geq {spd}_{G} ((s, t))$ konstruieren, so kann dieser zur Berechnung der oberen Schranke verwendet werden, etwa indem die Dijkstra Suchen auf ihm ausgeführt werden.
Alternativ kann $G'$ auch in einen Contracted- oder Hub-Graph umgewandelt werden, womit die obere Schranke dann für jedes Vorgänger Nachfolger Paar einzelnen berechnet wird.

Für Graphen in der euklidischen Ebene sind Triangulierungen aber leicht zu erstellen.
\todo{Weiter}

Weitere Methoden zur Vereinfachung eines Graphen, ohne den Abstand zwischen zwei Knoten zu verkleinern, werden in dieser Arbeit nicht weiter behandelt.
Es ist anzunehmen, dass die Genauigkeit der oberen Schranke und die Geschwindigkeit der Berechnungen auf dem vereinfachten Graphen im Widerspruch stehen.
Weiter sind solche vereinfachten Graphen im Allgemeinen schwer zu konstruieren.

Diese Methode lässtich besonders gut auf die in dieser Arbeit bearbeiteten Sichtbarkeitsgraphen und ihre Triangulierungen anwenden, da Triangulierungen eine obere Schranke für Sichtbarkeitsgraphen liefern und Berechnungen auf ihnen im Vergleich sehr effizient sind.

\subsection{Dreiecksungleichung}
Ähnlich zu ALT\cite{goldberg2005computing} kann eine Menge \emph{Hubs} berechnet werden, welche mittels der Dreiecksungleichung eine obere Schranke angeben können.
Ein Hub ist hierbei ein Knoten $l \in V$, für den die Distanz zu und von allen Knoten bekannt ist, die obere Schranke des Abstandes zweier Knoten $s, t \in V$ kann dann durch ${spd}_G ((u, l)) + {spd}_G ((l, u))$ berechnet werden.
Liegt $l$ dabei auf einem kürzesten Pfad von $u$ nach $v$, so entspricht der Wert sogar genau dem der kürzesten Pfad Distanz.
Die obere Schranke über mehrere Hubs wird durch die Wahl der kleinsten oberen Schranken bestimmt.
In der Implementation hierfür reicht es sogar, eine obere Schranke zu finden, die kleiner als die potenzielle Abkürzung ist, diese kann dann keine optimale Abkürzung sein.

Die Hubs können dabei über die Berechnung eines Hitting-Sets bestimmt werden.
Durch die Auswahl von Hubs auf diese Art steigt die Genauigkeit der oberen Schranken mit der Hop-Länge der kürzesten Pfade, da die Wahrscheinlichkeit, dass diese durch einen Hub getroffen wird, steigt.
Durch mehr Hubs steigt allerdings auch der Zeitbedarf der Berechnung der oberen Schranke.

\subsection{Kombination mehrer oberer Schranken}
Sind für eine Graph mehrere Heuristiken bekannt, so so kann für eine potenzielle Abkürzungen aus allen oberen Schranken die kleinste ausgewählt werden.
Dies ist besonders dann sinvoll, wenn die Heuristiken jeweils eine Teilmenge alle Knotenpaare gut abdecken.
Insbesondere die Kombination von Dreicksungleichung und vereinfachtem Graph ist hierbei erfeolgsversprechen unter der Annahme, dass die erste für große und zweitere für kleine Hop-Abstände gute obere Schranken liefert.

\section{Bottom-Up Heuristik}

Damit die Nachfolgenden Kontraktion einfacher werden ist nicht die Kanten Differenz interesannt, sondern $\sum_{n \in \text{Nachbarschaft}(v)} (\text{Grad}_\text{neu}(n))^2 - (\text{Grad}_\text{alt}(n))^2$.
Der Kantendifferenz ist es egal, dass alle neue Kanten zu einem einzigen Knoten gehen. Dieser Heuristik nicht.

% TODO das drinnne lassen?
% \section{Datenstrukturen}
% 
% Im Allgemeinen haben wir zwei Anforderungen an die verwendeten Datenstrukturen, welche zur Repräsentation der Graphen verwendet werden: Es muss möglich sein für einen Knoten seine Vorgänger und Nachfolger zu finden und es muss möglich sein Kanten zu verändern oder zu entfernen.
% Diese beiden Ansprüche stehen sich mitunter gegenüber.
% 
% Knoten und Distanzen werde in der Implentierung als uint32 repräsentiert.
% Als Grundbaustein wurden verschiedene Graphen implementiert, welche jeweils nur ihre Nachfolger kennen.
% Damit ein Graph auch seine Vorgänger kennt, wurden jeweils zwei dieser Graphen zusammen benutzt.
% 
% \subsection{VecVecGraph}
% 
% Ein VecVecGraph besteht aus einem Vektor mit jeweils einem Eintrag pro Knoten.
% Dieser Eintrag ist ein Vector über Tuple Knoten $\times$ Distanz, welche nach dem Knoten sortiert sind.
% Der Knoten entspricht dabei dem Kopf einer Kante, ihr Fuß ist der Index in dem ersten Vektor.
% Soll eine Kante gefunden werden, so muss im Vektor, welche mit dem Fuß gefunden wird, eine Binäre Suche nach dem Kopf gemacht werden.
% 
% Das Iterieren über von aus einem Knoten ausgehenden Kanten ist damit effizient, das finden einer bestimmten Kante für kleinere Grade auch.
% Bei größeren Graden kann die Binäre Suche jedoch eine einen negativen Perfomance Overhead darstellen.
% Gleiches gilt für das Einfügen von neuen und Löschen von bestehenden Kanten, denn für größere Grade müssen dafür eine größere Menge an Knoten geschoben werden.
% 
% \subsection{VecHashGraph}
% 
% Ein VecHashGraph besteht wieder aus einem Vektor mit jeweil einem Eintrag pro Knoten, welcher eine HashMap Knoten auf Distanz ist.
% Durch die ausgehenden Kanten kann dann iteriert werden, indem die HashMap, welche zum Fuß gehört aufgerufen wird und durch diese itertiert wird.
% 
% Das Iterieren über diese Kanten ist etwas ineffizienter, da die Einträge in der HashMap nicht konitunierlich im Speicher liegen und dadurch die Cache-Effizent sinkt.
% Dafür wird bei größeren Graden das Finden von spezifischen Kanten, sowie das Einfügen und Löschen effizenter.
% Eine in dieser Arbeit nicht benutzte aber interesannte Datenstruktu ist die HashMap, Effizientes Iterieren und Finden von Kanten mit inefieziennten Einfügen und Löschen verbindet.
% 
% \subsection{VecGraph}
% 
% Soll ein Graph nicht verändert werden, sondern nur zum Finden von Nachbarn in einer Dijkstra Suche benutxt werden, so bietet sich ein VecGraph an.
% Dieser besteht aus zwei Vectoren, einem Index Vektor mit je einem Eintrag pro Knoten der Form Startindex, Stopindex und einem Kanten Vector der Form Knoten, Distanz.
% Aus einem Knoten ausgehende Kanten lassen sich dann finden, indem im Indexvektor der Start- und Stopindex gefunden wird.
% Dieses Paar gibt an, wo im Kantenindex die dazugehörigen Kanten sind.
% Durch die Verwendung des Start- undt Stopindex lassen sich die Kanten von häufig benutzten Knoten an einem Ende des Knotenvektors grupieren, dadurch lässt sich die Wahrscheinlichkeit von Cache-Hits erhöhen.