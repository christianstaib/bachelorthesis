\chapter{Kontraktion in Graphen mit hohen Knotengraden}\label{chapter:kontraktion}

Die zuvor beschriebenen klassische Kontraktion stößt bei Graphen mit hohen Knotengraden an ihre Grenzen:
Bei der Kontraktion muss für jeden Vorgängerknoten eine Dijkstra-Suche durchgeführt werden, und für jedes Paar aus Vorgänger- und Nachfolger ist zu prüfen, ob eine Abkürzung eingefügt werden muss.
Bei der Bottom-Up Kontraktion wird die Kontraktion hierbei potentiell mehrfach ausgeführt, wobei beim Lazy Popping sich die Kantendifferenz häufig ändern wird (bei vielen Nachbarn ist es wahrscheinlich, dass einer dieser Kontraktiert wurde) und bei Neighbor Update sind viele Nachbarn zu Updaten.
Um Graphen mit hohen Knotengraden effizent zu kontrakieren ist es daher entscheidend, sowohl die Kontraktion einzelner Knoten als auch die des gesamten Graphen zu beschleunigen.

\section{Kontraktion mit oberer Schranke}
Anstelle einer potenziell rechenintensiven Dijkstra-Suche pro Vorgänger kann eine Heuristik pro Paar aus Vorgänger und Nachfolger eine obere Schranke für den Abstand geben.
Eine Abkürzung wird dann eingefügt, wenn die Länge der potenziellen Abkürzung kleiner oder gleich der oberen Schranke ist.
Damit dies für die Kontraktion eines einzelnen Knotens effizienter ist, muss die Ermittlung der Heuristik für alle Paare eines bestimmten Vorgängers und aller Nachfolger schneller sein als die Dijkstra-Suche.
Damit die Kontraktion des gesamten Graphen effizienter ist, müssen die Folgekosten unnötigerweise eingefügter Kanten kleiner sein als die Summe des Zeitgewinns durch die Verwendung der Heuristik.
Im Follgenden werden verschiedene Heuristiken diskutiert.

\subsection{Triviale Heurisik}
Die \emph{Triviale Heuristik} setzt die obere Schranke für jedes Knotenpaar auf $\infty$.
Dies bedeutet, dass für jedes Paar aus Vorgänger- und Nachfolgerknoten eine Abkürzung eingefügt wird, unabhängig von der tatsächlichen kürzesten Pfad Distanz zwischen den Knoten.
Unter der Annahme, dass in Graphen mit sehr hohem Knotengrad fast alle Nachbarn bereits mit einer Kante verbunden sind, könnte der Anteil der unnötig eingefügten Abkürzungen im Verhältnis zu den notwendig eingefügten Abkürzungen vernachlässigbar sein.

\subsection{Vereinfacher Graph}
Sei $G = (V, E)$ der zu Kontraktierende Graph.
Lässt sich zu $G$ effizient ein vereinfachter Graph $G' = (V, E')$ mit $\forall s, t \in V \colon {spd}_{G'} ((s, t)) \geq {spd}_{G} ((s, t))$ konstruieren, so kann dieser zur Berechnung der oberen Schranke verwendet werden, etwa indem die Dijkstra Suchen auf ihm ausgeführt werden.
Alternativ kann $G'$ auch in Contracted oder Hub Graph umgewandelt werden, womit die obere Schranke dann für jedes Vorgänger Nachfolger Paar einzelnen berechnet wird.

Methoden zur Vereinfachung eines Graphens ohne Verkleinerung des Abstandes zweier Knoten werden in dieser Arbeit nicht weiter diskutiert, es ist Anzunehmen, dass die Genauigkeit der oberen Schranke und die Geschwindigkeit der Berechnungen auf dem vereinfachten Graphen im Widerspruch stehen.
Weiter sind solche vereinfachten Graphen im Allgemeinen schwer zu konstruieren.

Jedoch lässt sich diese Methode besonders gut auf die in dieser Arbeit bearbeiteten Sichtbarkeitsgraphen und ihre Triangulierungen anwenden, da zweitere eine obere Schranke für erste liefern und Berechnungen auf Ihnen im Vergleich sehr effizent sind.

\subsection{Dreickunsgleichung}
Ähnlich zu ALT\cite{goldberg2005computing} kann eine Menge \emph{Hubs} berechnet werden, welche mittels der Dreiecksungleichung eine obere Schranke angeben können.
Ein Hub ist hierbei ein Knoten $l \in V$, für den die Distanz zu und von allen Knoten bekannt ist, die obere Schranke des Abstandes zweier Knoten $s, t \in V$ kann dann durch ${spd}_G ((u, l)) + {spd}((l, u))$ berechnet werden
Liegt $l$ dabei auf einem kürzesten Pfad von $u$ nach $v$, so entspricht der Wert sogar genau dem der kürzesten Pfad Distanz.
Die obere Schranke über mehrere Hubs wird dabei durch die Wahl der kleinsten oberen Schranke bestimmt.
In der Implementation hierfür reicht es sogar, eine obere Schranke zu finden, die kürzer als die potentielle Abkürzung ist, diese kann dann keine otpimale Abkürzung sein.

Die Hubs können dabei über die Berechnung eines Hitting-Sets bestimmt werden.
Durch die Auswahl von Hubs auf die Art steigt Genauigkeit der oberen Schranken mit der Hop-Länge der kürzesten Pfade, da die Wahrscheinlichkeit, dass diese durch einen Hub getroffen wird, steigt.
Durch mehr Hubs steigt allerdings auch der Zeitbedarf der Berechnung der oberen Schranke.

\subsection{Kombination mehrer oberer Schranken}
Sind für eine Graph mehrere Heuristiken bekannt, so so kann für eine potentielle Abkürzungen aus allen oberen Schranken die kleinste ausgewählt werden.
Dies ist besonders dann sinvoll, wenn die Heuristiken jeweils eine Teilmenge alle Knotenpaare gut abdecken.
Insbesondere die Kombination von Dreicksungleichung und vereinfachtem Graph ist hierbei erfeolgsversprechen unter der Annahme, dass die erste für große und zweitere für kleine Hop-Abstände gute obere Schranken liefert.

\section{Bottom-Up Heurisik}

Damit die Nachfolgenden Kontraktion einfacher werden ist nicht die Kanten Differenz interesannt, sondern $\sum_{n \in \text{Nachbarschaft}(v)} (\text{Grad}_\text{neu}(n))^2 - (\text{Grad}_\text{alt}(n))^2$.
Der Kantendifferenz ist es egal, dass alle neue Kanten zu einem einzigen Knoten gehen. Dieser Heuristik nicht.

% TODO das drinnne lassen?
% \section{Datenstrukturen}
% 
% Im Allgemeinen haben wir zwei Anforderungen an die verwendeten Datenstrukturen, welche zur Repräsentation der Graphen verwendet werden: Es muss möglich sein für einen Knoten seine Vorgänger und Nachfolger zu finden und es muss möglich sein Kanten zu verändern oder zu entfernen.
% Diese beiden Ansprüche stehen sich mitunter gegenüber.
% 
% Knoten und Distanzen werde in der Implentierung als uint32 repräsentiert.
% Als Grundbaustein wurden verschiedene Graphen implementiert, welche jeweils nur ihre Nachfolger kennen.
% Damit ein Graph auch seine Vorgänger kennt, wurden jeweils zwei dieser Graphen zusammen benutzt.
% 
% \subsection{VecVecGraph}
% 
% Ein VecVecGraph besteht aus einem Vektor mit jeweils einem Eintrag pro Knoten.
% Dieser Eintrag ist ein Vector über Tuple Knoten $\times$ Distanz, welche nach dem Knoten sortiert sind.
% Der Knoten entspricht dabei dem Kopf einer Kante, ihr Fuß ist der Index in dem ersten Vektor.
% Soll eine Kante gefunden werden, so muss im Vektor, welche mit dem Fuß gefunden wird, eine Binäre Suche nach dem Kopf gemacht werden.
% 
% Das Iterieren über von aus einem Knoten ausgehenden Kanten ist damit effizient, das finden einer bestimmten Kante für kleinere Grade auch.
% Bei größeren Graden kann die Binäre Suche jedoch eine einen negativen Perfomance Overhead darstellen.
% Gleiches gilt für das Einfügen von neuen und Löschen von bestehenden Kanten, denn für größere Grade müssen dafür eine größere Menge an Knoten geschoben werden.
% 
% \subsection{VecHashGraph}
% 
% Ein VecHashGraph besteht wieder aus einem Vektor mit jeweil einem Eintrag pro Knoten, welcher eine HashMap Knoten auf Distanz ist.
% Durch die ausgehenden Kanten kann dann iteriert werden, indem die HashMap, welche zum Fuß gehört aufgerufen wird und durch diese itertiert wird.
% 
% Das Iterieren über diese Kanten ist etwas ineffizienter, da die Einträge in der HashMap nicht konitunierlich im Speicher liegen und dadurch die Cache-Effizent sinkt.
% Dafür wird bei größeren Graden das Finden von spezifischen Kanten, sowie das Einfügen und Löschen effizenter.
% Eine in dieser Arbeit nicht benutzte aber interesannte Datenstruktu ist die HashMap, Effizientes Iterieren und Finden von Kanten mit inefieziennten Einfügen und Löschen verbindet.
% 
% \subsection{VecGraph}
% 
% Soll ein Graph nicht verändert werden, sondern nur zum Finden von Nachbarn in einer Dijkstra Suche benutxt werden, so bietet sich ein VecGraph an.
% Dieser besteht aus zwei Vectoren, einem Index Vektor mit je einem Eintrag pro Knoten der Form Startindex, Stopindex und einem Kanten Vector der Form Knoten, Distanz.
% Aus einem Knoten ausgehende Kanten lassen sich dann finden, indem im Indexvektor der Start- und Stopindex gefunden wird.
% Dieses Paar gibt an, wo im Kantenindex die dazugehörigen Kanten sind.
% Durch die Verwendung des Start- undt Stopindex lassen sich die Kanten von häufig benutzten Knoten an einem Ende des Knotenvektors grupieren, dadurch lässt sich die Wahrscheinlichkeit von Cache-Hits erhöhen.