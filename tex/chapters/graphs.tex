\chapter{Graphen}

Mathematisch sind die in dieser Arbeit benutzten Graphen definiert als Tuple $(V, E)$ mit $V \subset \mathbb{N}$, $E \subset V \times V \times \mathbb{N}$ und $V$, $E$ endlich. Für die Sichtbarkeitsgraphen und den dazugehörigen triangulierten Graphen gilt, das ein Vertex $v \in \mathbb{N}$ in beiden Graphen vorhanden ist, so handelt es sich dabei um denselben Vertex.

${out}(G)$ ist der \emph{Out-Graph} von $G$


${in}(G)$ ist der \emph{In-Graph} von $G$

Funktionen
${sp}_{G}$ shortest path Funktionen auf $G$

${spd}_{G}$ shortest path distance Funktion. $G$

$c$ Kanten costen function

Verschieden Graph Strukturen

Grundlegende Idee:
Ein Interface Graph welches nur ausgehende Kanten kennt.
get edge distance, set edge distance

Dieses habe ich für verschiedene Graphen implementiert.
Wichtigste:
VecVec: Ein Vec. Jeder Vertex hat hat einen Eintrag vom Typ Vec in dem die kanten sortiert nach Head sind.
VecHashMap: Ein Vec. Jeder Vertex hat einen Eintrag vom Typ HashMap (Head, Distance).
Vec: Zwei Vec. Einer für (Head, Distance), zweiter für startindex, stopindex für Vec.
TODO Indexmap?

Häufig eine Abwägung wie schnell gequeriet werden kann vs wie schnell bearbeitet werden kann.


für reverse dijkstra uä muss aber auch Vorgänger bekannt sein.
Idee: Reversible Graph aus einem Vorwärtsgrapg und Rückwärtgraph
Beide sind aber grundätzlich gleiche Struktur. Daher ist Vorwärts und Rückwärtssuche gleiche Funktion.


Gleiches gilt für Contracted Graph. Zwei Graphen Upward Graph und Downward Graph. Downward Graph ist aber \"umgedreht\" zur Definition aus dem Paper, es wird also beides mal eine Vorwärtssuche gemacht.


\section{Graph File Format}
Beliebig viele Kommentar lines
leere line
num Vertices
num Edges
Vertices
Edges

Suche
Für Dijkstra verscheidene Datenstrukturen getestet.
Data (predecessor, distance)
Queue (min heap)
is\_expanded

jeweils ein Interface.

TODO. Testen verschiedener Kombinationen.
TODO. Wann ist reuse of allocation sinvoll?
TODO Decrease key

